[
  {
    "Text": "Wenn Du auf Play drückst, wird der aktuell betrachtete Knoten mit einem grünen Rahmen hervorgehoben. Somit siehst Du immer, wo Dein Programm gerade steht!",
    "Source": "Hints/highlight.png"
  },
  {
    "Text": "Ein doppelter Mausklick auf einen Knoten macht diesen zum Startknoten. Die Ausführung Deines Programms startet dann immer mit diesem Knoten. Der Startknoten ist durch einen dicken roten Rand hervorgehoben.",
    "Source": "Hints/startnode.png"
  },

  {
    "Text": "Template Strings sind eine gute Methode, um statische Texte und Variablen formatiert in einem String zu kombinieren. Um einen Template String zu verwenden, kannst Du einfach die C# Notation nutzen. Beispielsweise führt s = \"Hallo\", name = \"Linus\", template = $\"{s} {name}\" zu \"Hallo Linus\"",
    "Source":  "Hints/template-strings.png"
  },
  {
    "Text": "Eine Alternative (Rautensymbol) braucht eine Bedingung, die sich mit Ja oder Nein beantworten lässt. Dann braucht sie jeweils einen Pfad für die beiden Fälle - also einen für den Fall, dass die Bedingung zutrifft und einen Pfad für den Fall, dass sie nicht zutrifft. Die Pfade können sich im weiteren Programmverlauf treffen, müssen es aber nicht.",
    "Source": "Hints/animalquiz.png"
  },
  {
    "Text":  "Um die Kanten bei einer alternative dem entsprechenden Pfad (Ja / Nein) zuzuordnen, reicht ein einfacher Mausklick. Achte immer darauf, bei einer Verzweigung die Kanten richtig zuzuordnen!",
    "Source":  "Hints/alternatives.png"
  },
  {
    "Text": "Verwende Terminalsymbole (Ovale), um Funktionen und Unterprogramme zu modellieren. Im Feld 'InputVariables' trägst Du die Variablen ein, die als Parameter übernommen werden sollen. Willst Du eine Variable zurückliefern, so trägst Du sie im Feld 'Return Variable' ein. Das entspricht dem Schlüsselwort 'return' in C#. Für die entsprechenden Felder musst Du den richtigen Typ von Terminalsymbol (Start/End) auswählen.",
    "Source": "Hints/terminals.png"
  },
  {
    "Text": "Um eine Funktion oder ein Unterprogramm aufzurufen, verwendest Du einen 'Predefined process' Knoten, also das Rechteck mit den vertikalen Balken. Der Code entspricht dann dem, was Du in C# tun würdest, folgt also dem Schema [Variable] = [Funktionsname]([Parameter, getrennt durch Komma])",
    "Source": "Hints/processcalls.png"
  },
  {
    "Text": "Wenn Du einen Sequenz- oder Entscheidungsknoten auswählst, gelangst Du mit der Taste F2 in die Codeansicht. Hier kannst Du längere Anweisungen schreiben, die sich in der Standardansicht nicht ausgehen. Außerdem bekommst Du nützliche Codefragmente, um Probleme schneller lösen zu können. Klicke einfach doppelt auf die Codezeile auf der rechten Seite, um sie ins Codefenster zu übertragen.",
    "Source": "Hints/F2Window.png"     
  },
  {
    "Text": "Eine kopfgesteuerte Schleife (For-Schleife oder Zählschleife) braucht eine Initialisierung, eine Bedingung (mit ja / nein zu beantworten), einen Schleifenrumpf und ein Inkrement (eine Aktualisierung)",
    "Source": "./Hints/For-Loop-With-Output.png"
  },
  {
    "Text": "Eine fußgesteuerte Schleife (Do-While Schleife) braucht eine Initialisierung, eine Bedingung (mit ja / nein zu beantworten), einen Schleifenrumpf und ein Inkrement (eine Aktualisierung)",
    "Source": "Hints/do-while-loop.png"
  },
  {
    "Text": "Im Variablenfenster siehst Du zu jedem Zeitpunkt, welchen Wert Deine Variablen haben - nutze dieses Werkzeug zur Fehlersuche!",
    "Source": "Hints/variableview.png"
  },
  {
    "Text": "Im Aufrufsfenster siehst Du zu jedem Zeitpunkt, welche Unterprogramme und Funktionen bisher aufgerufen wurden und in welcher Reihenfolge. Das macht das Verständnis von rekursiven Algorithmen viel einfacher!",
    "Source": "Hints/fibonacci.png"
  }
]